
CALL REWRITE:

As Ctors require two phases of usurpation, it suddenly becomes more efficient to create CallArgs
up front, and to use these solely in place of private fields in each special Call.

Cuckoos can then edit arg values in place, without a secret updating of the interior fields after
every stage of potential user interaction. The final inner method will have its arg stack populated
directly from these CallArgs.

And why not a similar set-up for the return value? 

A single light-weight Call instance will house the CallArg array and return value, and will be passed
from Cuckoo to Cuckoo in its various stages, finally offering up its modified contents to the final
inner method invocation.

Calls will therefore not be dispatchers; the Roost will be subclassed more extensively to feed the 
Cuckoos it contains.

Each call will be of Call<TReturn>, removing the need for IL subclassing of the same.


Calls will store a callback reference to the dispatcher, and on CallInner will delegate to this
dispatcher. The dispatcher will internally keep tabs on which phase of the overall invocation it is at,
and will switch to the correct inner invocation appropriately. This will however mess up the stack...

So this will separate the call and dispatcher, both of which must be stateful, and therefore both 
must be created anew for each overall invocation. The roost is static.

Instead of this ping-pong, it would make more sense for each call to be its own dispatcher, as this
would minimise object allocation, but at the cost of conflation in the design. Calls would remain
hard-coded in IL (in part at least, as specialised subclasses).

The outer method creates the CallDispatcher (of ICall) and calls Dispatch().


NEW ROOSTS:

Roosts will build methodinfo, create a call object, pass this call to its various cuckoos,
and then invoke the inner method with the contents of the call. 











CTORS:
> Are special cases, in that delegation to base ctor must occur in outer!

Need OnBeforeCall to provide opportunity to change args before ctor interior stuff.


1 - Init cascade: constructs hierarchy of calls, each with its target in place
2 - OnBeforeCall cascade
3 - Ctor init at base
4 - OnCall cascade
5 - Return
...

OnCall and OnBeforeCall will become virtual rather than abstract

OnBeforeCall should cascade down through cuckoos...












********************************************************************
TO DO:

> Change to single array of CallArgs, passed throughout stack - no lazy-loading, unfortunately
	- would be best if CallArgs were structs, no - they store very little info (value + ref to ParamInfo)
> Cuckoos on Constructors
> interface + abstract methods
> structs rather than classes
> async
> Calls to have bespoke little method/param info classes, with lazy GetParameterInfo() and GetMethodInfo() funcs
> Use abstract CallBase class, with only sub-methods emitted
> Test Cuckoos declared in other assemblies
> Beware array types: in both ctor args and gen params!
> Return value to police its type
> CallInner and Proceed to check call phase
> Nullable types in generic args



*******************************************************************
DOUBTFUL:

> Light-weight SyncLock on lazy args creation
	- args are only created once per call, but cuckoo may thread off and access args from there...



*******************************************************************
DONE:
> Static classes DONE
> Static methods DONE
> Optional args in CuckooAttributes DONE
> Optional args in cuckooed methods DONE
> CallArg<T> classes, deriving from exposed ICallArg DONE
> CallArgs should check type of value set DONE
> ByRef parameters DONE
> Cooler lambda-based MethodTester DONE
> Generic classes DONE
> Multiple cuckoos in one nest DONE
> Init to be called DONE
> Change returned value DONE
> Args wrapped in classes DONE
> Name-provision encapsulated DONE
> Generic methods: generic args + generic return DONE
