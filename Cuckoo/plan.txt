
********************************************************************
TO DO:

> SUDDEN CRISIS!!!
	ValueTypes can't have their instance communicated by value, as the cuckooed inner
	will then operate on a copy. (SET UP A TEST TO PROVE THIS)

	The address MUST reach the inside, and the only way for to occur is for it to be
	passed by arg. The invocation mechanism within CallBase must therefore be emitted
	rather than written in C#.

	This is a significant pain, but does at least force me to allow change tracking.



	All values can be passed by args to the invocation funcs, but how can the same values
	be passed via ICall.CallInner? There's no way, unless we tolerate unsafe assemblies
	storing pointers.

	Only way to do it would involve some ugly nastiness involving special CallInner methods
	and a requirement for the user to manually pass through the struct value byref. This is
	unacceptable; and, as struct methods should hardly ever be cuckoed anyway, the best course
	now would be to outlaw such usage, along with CuckooProviders on abstract methods.



	Could we copy back by value? That would work, I reckon, though there might be an issue
	with threading (there would be an issue with this anyway unless locks were used).

	The inner method gets called on OUR version of the valuetype, sitting pretty in a call field,
	and potentially alters it there; only afterwards, as some final, final act - along with the
	copying back of byref args.


	FIRST OF ALL - NEED TO WRITE A TEST TO EXPOSE THIS PROBLEM then fixit.






> Hide stack as much as we can
> NuGet
> Mono


*******************************************************************
DONE:
> Clean away MethodDecorator remnants DONE
> Remove and sort all usings DONE
> structs rather than classes DONE
> virtual methods DONE
> check attributes not inherited DONE
> Test Cuckoos declared in other assemblies DONE
> Extension methods DONE
> ICuckooProvider DONE
> Property accessors DONE
> Beware array types: in both ctor args and gen params! DONE
> Nullable types in generic args DONE
> async DONE
> Return value to police its type DONE
> Cuckoos on Constructors DONE
> Static roost field to be nested within Call class DONE
> Static classes DONE
> Static methods DONE
> Optional args in CuckooAttributes DONE
> Optional args in cuckooed methods DONE
> CallArg<T> classes, deriving from exposed ICallArg DONE
> CallArgs should check type of value set DONE
> ByRef parameters DONE
> Cooler lambda-based MethodTester DONE
> Generic classes DONE
> Multiple cuckoos in one nest DONE
> Init to be called DONE
> Change returned value DONE
> Args wrapped in classes DONE
> Name-provision encapsulated DONE
> Generic methods: generic args + generic return DONE
